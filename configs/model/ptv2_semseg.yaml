# ════════════════════════════════════════════════════════════════════════════
# PointTransformerV2 语义分割模型配置
# ════════════════════════════════════════════════════════════════════════════
#
# PTv2 (Point Transformer V2) 是高效的点云 Transformer 架构
# 核心特点:
#   - 使用 Grid Pooling 替代 FPS 实现层次化下采样
#   - Group Vector Attention 减少计算复杂度
#   - Partition-based Pooling 保持结构信息
#
# 此文件定义模型架构配置，可在 experiment yaml 中覆盖任意参数
#
# 配置结构:
#   - backbone: 特征提取网络 (Encoder-Decoder)
#   - head: 任务头 (分割头)
# ════════════════════════════════════════════════════════════════════════════

# ════════════════════════════════════════════════════════════════════════════
# Backbone: PointTransformerV2
# ════════════════════════════════════════════════════════════════════════════
# U-Net 结构: Encoder 下采样提取特征，Decoder 上采样恢复分辨率
backbone:
  class_path: pointsuite.models.PointTransformerV2
  init_args:
    # ─────────────────────────────────────────────────────────────
    # 输入配置
    # ─────────────────────────────────────────────────────────────
    # 输入特征维度: 必须与 data.transforms 的 feat 输出匹配
    # 本配置: coord(3) + echo(2) = 5
    in_channels: 5
    
    # ─────────────────────────────────────────────────────────────
    # Patch Embedding (点云分块嵌入)
    # ─────────────────────────────────────────────────────────────
    # 将原始点云转换为初始特征表示
    patch_embed_depth: 1          # Embedding 层数
    patch_embed_channels: 24      # Embedding 输出通道数
    patch_embed_groups: 6         # Group Attention 分组数
    patch_embed_neighbours: 24    # K近邻数量
    
    # ─────────────────────────────────────────────────────────────
    # Encoder 配置 (下采样路径)
    # ─────────────────────────────────────────────────────────────
    # 4 个阶段，逐层下采样，通道数递增
    enc_depths: [2, 2, 2, 2]              # 每阶段 Transformer Block 数量
    enc_channels: [48, 96, 192, 256]      # 每阶段输出通道数
    enc_groups: [6, 12, 24, 32]           # 每阶段 Group Attention 分组数
    enc_neighbours: [32, 32, 32, 32]      # 每阶段 K近邻数量
    
    # ─────────────────────────────────────────────────────────────
    # Decoder 配置 (上采样路径)
    # ─────────────────────────────────────────────────────────────
    # 4 个阶段，逐层上采样，通道数递减
    dec_depths: [1, 1, 1, 1]              # 每阶段 Transformer Block 数量
    dec_channels: [24, 48, 96, 192]       # 每阶段输出通道数
    dec_groups: [4, 6, 12, 24]            # 每阶段 Group Attention 分组数
    dec_neighbours: [32, 32, 32, 32]      # 每阶段 K近邻数量
    
    # ─────────────────────────────────────────────────────────────
    # Grid 配置 (体素采样)
    # ─────────────────────────────────────────────────────────────
    # 每阶段的体素大小，层层递增 (约 2.5 倍)
    # 决定了每层的点云密度和感受野大小
    grid_sizes: [1.5, 3.75, 9.375, 23.4375]
    
    # ─────────────────────────────────────────────────────────────
    # Attention 配置
    # ─────────────────────────────────────────────────────────────
    # Query/Key/Value 投影是否使用偏置
    attn_qkv_bias: true
    # 位置编码是否使用乘法模式
    pe_multiplier: false
    # 位置编码是否使用偏置
    pe_bias: true
    # Attention Dropout 比例 (0 表示不使用)
    attn_drop_rate: 0.0
    # DropPath 比例 (随机深度正则化)
    drop_path_rate: 0.3
    
    # ─────────────────────────────────────────────────────────────
    # Unpool 配置 (上采样方式)
    # ─────────────────────────────────────────────────────────────
    # 上采样后端:
    #   - interp: 基于距离的插值 (推荐)
    #   - map: 基于索引映射
    unpool_backend: interp

# ════════════════════════════════════════════════════════════════════════════
# Head: Segmentation Head (分割头)
# ════════════════════════════════════════════════════════════════════════════
# 将 Backbone 输出的特征映射到类别预测
head:
  class_path: pointsuite.models.SegHead
  init_args:
    # 输入通道数: 必须与 Decoder 最后一层输出匹配
    # 对应 dec_channels[0] = 24
    in_channels: 24
    
    # 输出类别数: 在 experiment yaml 中通过 ${data.classes.num_classes} 配置
    # num_classes: (由 experiment 覆盖)
